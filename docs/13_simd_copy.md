# 13. SIMDを用いたデータコピー

## 画面表示の高速化

`09_display_lib.c`は色を計算しながら1バイトずつ書き込むプログラムだったが、
これは環境によっては描画の過程がはっきり見えるほど遅かった。
もっと高速に書き込めるようにしないと、実用は難しそうだ。

そこで、まず事前に色を計算し、それを4バイトずつコピーするプログラム
`13_display_lib_buffer.c`を作成した。
これにより1バイトずつ書き込むよりは速くなったが、まだ描画の過程が見える。

## SIMDを用いたデータコピー

4バイトずつの書き込みでも遅かったので、
、SIMD(AVX/SSE)を使用してさらなる高速化を図ったプログラム
`13_display_lib_simd.c`を作成した。
その結果、描画の過程があまり目立たないようになった。

なお、SIMDを使用するには、有効化フラグを立てないといけないようである。
その前に、CPUが対応しているかチェックするべきだ。
対応しているかのチェックは、CPUID命令を用いて、
SSEはFXSRとSSEに対応しているか、AVXはXSAVEとAVXに対応しているかで判定できる。

対応チェックについては、以下のサイトなどが参考になる。

* [CPUID - OSDev Wiki](https://wiki.osdev.org/CPUID)
* [waura's blog – CPUID命令を使用して、SSEに対応しているか調べるコード](https://waura.github.io/200909121252748821.html)
* [Is AVX enabled?](https://software.intel.com/content/www/us/en/develop/blogs/is-avx-enabled.html)
  * この記事ではXSAVEの存在をビット27で判定しているが、このビットはCR4の設定に連動するため、ビット26で判定するべきである。

SSEを有効化するには、CR4の9ビット目(OSFXSR)を1にする。
AVXを有効化するには、CR4の18ビット目(OSXSAVE)を1にし、
さらにXCR0の1ビット目(SSE)と2ビット目(AVX)を1にする。

有効化については、以下のサイトなどが参考になる。

* [CPU Registers x86-64 - OSDev Wiki](https://wiki.osdev.org/CPU_Registers_x86-64)
* [XGETBV — Get Value of Extended Control Register](https://www.felixcloutier.com/x86/xgetbv)
* [XSETBV — Set Extended Control Register](https://www.felixcloutier.com/x86/xsetbv)
* [Control register - Wikipedia](https://en.wikipedia.org/wiki/Control_register)

今回はデータのコピーをするだけなので、例外の処理や割り込み時のレジスタの退避は考えなくて良いが、
SIMDを本格的に利用したい場合は、それらを実装することになるだろう。
それはまた要求される時に考えることとする。

## 割り込み時のレジスタの退避

…とはいえ、コピーだけだとしても割り込みは起こるかもしれない。
そこで、レジスタの退避は実装しておこう。

* x87のみ
* x87とSSE
* x87とSSEとAVX

それぞれの対応状況に合わせ、それぞれ

* [FSAVE](https://www.felixcloutier.com/x86/fsave:fnsave)
* [FXSAVE](https://www.felixcloutier.com/x86/fxsave)
* [XSAVE](https://www.felixcloutier.com/x86/xsave)

で退避を行う。

FSAVEのアラインメントの制約は書かれておらず、
FXSAVEは16バイト、XSAVEは64バイトのアラインメントが要求される。

さらに、
[Intel® 64 and IA-32 Architectures Software Developer Manuals](https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html)
のVolume 3の13.5.4によると、XSAVEを使う前にXSAVE headerをゼロクリアしないといけないようである。
XSAVE headerは、XSAVEで使う領域の512バイト目からの64バイトである。 (Volume 1の13.4.2より)

### 遅延退避

保存に用いる領域のサイズは、
FSAVEは94バイトまたは108バイトとなっているので大きい方をとって108バイト、
FXSAVEは512バイト、
XSAVEはEAX=0x0D,ECX=0としたCPUIDのEBXで得られるサイズ(SSEとAVXの場合、例えば832バイト)である。

このような比較的大きなデータを割り込みのたびにスタックに確保し、
メモリの読み書きをするというのは、効率が悪そうな気がする。
そこで、CR0のTSフラグを用いた遅延退避を行う。
TSフラグを立てておくと、FPUを使おうとした時に`#NM (7)`のトラップがかかるので、
そこで退避操作を行うことができる。

今回は、TSフラグを「本来FPU状態を退避するべき状況があったけど、まだ退避していない」
ということを表すフラグとして考える。
また、退避領域の状態を

* no (退避は不要)
* maybe (この後遅延退避するかもしれない)
* yes (退避した)

にわける。

割り込みが入り、FPU状態の退避を考えた時、

* TSフラグがオフの場合
  * 割り込み前にFPUを使っているかもしれないので、状態をmaybeにして、TSフラグを立てる
* TSフラグがオンの場合
  * 前回の(遅延)退避からFPUを使っていないので、状態をnoにする

割り込みから戻り、FPU状態の復帰を考えた時、

* 状態がnoの時
  * 何もしない
* 状態がmaybeの時
  * この割り込みに入る時にTSフラグを立てたはずなので、TSフラグを折る
* 状態がyesの時
  * TSフラグが立っているなら、退避を実行する (さもないと、次の復帰により退避するべき状態が消える)
  * FPU状態を復帰する

退避の実行(`#NM`トラップまたは状態yesでの復帰前)は、以下のように行う。

1. TSフラグを折る
2. TSフラグを立てた時に要求した位置(状態はmaybeのはず)に、FPU状態を保存する
3. FPUを初期化する
4. その位置の状態をyesにする

先にTSフラグを折ってから状態を保存しないと、
状態を保存するための命令で`#NM`トラップが発生してしまい、無限再帰になってしまうだろう。

割り込みは関数の途中から入っていることがあり、
そのままだと中途半端な状態のFPUで割り込みハンドラを実行することになってしまう可能性があるので、
それを防ぐためにFPUの初期化を行う。
FSAVEの処理にはFPUの初期化が含まれるが、
FXSAVEやXSAVEには含まれないようなので、別にFINITで初期化しておく。

また、LattePandaでの実験において、
最初の関数の実行前にFINITを実行しておかないと、浮動小数点演算がうまくできなかった。

さらに、FPUを使わないプログラムにおいて無駄に領域を確保するのを防ぐため、
最初はTSフラグを立てておく。
このとき、遅延退避要求位置はNULLとして、
退避の実行時に要求位置がNULLの場合はTSフラグを折るだけで状態の保存はしないようにする。

動作を確かめるため、`13_fpu_interrupt.c`を用意した。
これだけでは動作を確かめるのは難しいが、

* 手動でコンパイルして浮動小数点演算にSSEを使うようにする
  * x87だと、スタックを使っているなどの関係でうまく壊れない？
* `interrupt.c`でのFPU退避の初期化後に、`fpuSaveMode = FPU_NONE;`を入れて退避を無効化する
  * 初期化自体を無効化してしまうと、SSEも初期化されないのでうまく実行できないはず

とすることで、FPU状態を保存せずに割り込み処理をすることで動作が壊れることを確認できた。
さらに、退避を実行した時にシリアル出力を行うようにすることで、
割り込みハンドラ内でFPUを使った時だけ退避を行っていることも確認できた。

### 遅延退避の懸念

遅延退避により余計なFPU状態の退避を減らすことができ、効率が上がりそうであるが、
現在の実装では以下のような懸念がある。

* 将来マルチコアを有効化した時、TSフラグはコアの数だけあるのに、
  遅延退避要求位置の保存は1個だけなので、競合して悪いことが起こる。
  * マルチコアを有効化する場合、コアごとにデータを保存する方法が要求されるだろう。
* 将来マルチプロセス・マルチスレッドを実装した際、FPUを退避するだけでデータのクリアをしないと、
  残っているデータがそのまま読まれ、情報漏洩につながりそう。
  * データのクリアをするべきだろう。
    ただ、プロセスやスレッドを切り替えるタイミングでクリアすればいいだけかもしれないので、
    そのへんはそれらを実装する時によく考えよう。
  * そもそも、計算で使って潰れる可能性が高そうなだけで、普通のレジスタにも同じ問題がありそう。
* プロセスやスレッドを終了し、スタックを開放する時、
  遅延退避要求位置がそのスタックを指していると、dangling pointerになってしまい、危険。
  * 遅延退避要求位置が開放されるスタックを指している場合、
    スタックの開放時に遅延退避要求位置をNULLにする。
    NULLの場合は保存をしない仕様にしたので、これだけでいい。
    TSフラグは立てたままにしておくことで、
    FPUを使っていないのに無駄に退避用領域を確保するのを防ぐことができる。
