# 7. ページング

ページングを用いることで、物理アドレスの配置にとらわれずに論理アドレスを確保することができる。
そのため、

* 物理アドレスだとメモリが無い高位のアドレスにおけるプログラムの実行
* 物理アドレスだと不連続な領域を用い、大きい連続した領域を作成

などができる。

## 第一段階

とりあえずページングを有効にし、高位のアドレスでプログラムを実行開始することを目標とする。
そのために、アセンブリ言語(`entry_paging.S`)で処理を行う。

今回は、UEFIがプログラムを0x00400000以降に読み込んでくれるように設定するが、
プログラムは0xc0000000以降にある前提で実行したい。
そこで、まず0xc0000000に配置する設定でコンパイルを行い、
後から配置アドレスを0x00400000に書き換える。
この配置アドレスを書き換える機能を、`exe2img.pl`に追加した。

まずは、設定が最小限で済む4MBページングを用い、以下の設定を行う。

* 論理アドレスの0x00000000～0xbfffffffを同じ物理アドレスにマップする。
* 論理アドレスの0xc0000000以降を物理アドレスの0x00400000以降にマップする。

0x00400000という数字はちょうど先頭から4MBなので、ちょうど都合がいい。

4MBページングを有効にするには、cr4レジスタのpseビットを1にする。
[CPU Registers x86 - OSDev Wiki](https://wiki.osdev.org/CPU_Registers_x86)

ページングの設定であるPDE(とPTE)については、ここが参考になる。
[０から作るOS開発　ページングその１　ページとPTEとPDE](http://softwaretechnique.web.fc2.com/OS_Development/kernel_development07.html)

cr0レジスタのPGビットを1にすることで、ページングを有効にする。
[０から作るOS開発　カーネルローダその３　プロテクティッドモードへの移行とA20](http://softwaretechnique.web.fc2.com/OS_Development/kernel_loader3.html)

## 第2段階

4KBページングを用い、以下の設定を行う。

* プログラムの領域を過不足無く確保する。
* スタックの領域を高位に確保する。
* 空いている物理ページを一覧にし、取得できるようにする。
* 将来に備え、物理ページが空いているかを参照カウントで判定できるようにする。

まず、空いている物理ページの一覧を取得するために、
「4. メモリ探検」で開発したヒューリスティックを用いてメモリマップを得て、
available(7)のページを一覧にする。
ページは全部で1,048,576個あり、それぞれを4バイトのアドレスで表現すると4MBになる。
4MBなら十分小さいと思い、普通に配列をC言語でグローバルで確保しようとすると、
起動に失敗するようになってしまった。
どうやら、空いているメモリの合計は十分あっても、
0x00400000から連続して確保しようとすると、availableでない場所にぶつかってしまってダメなようだ。

そこで、まず物理ページ一覧用の領域を少なく確保し、
配列を確保できるだけの空き物理ページを集める。
それを用いて論理アドレスに配列を確保し、その配列を用いて残りのリストアップを行う。
という仕組みにすることにした。
この時、この仮配列をローカル(スタック)に確保すると、
`__chkstk_ms`が定義されていないという謎のエラーが出てしまった。
そこで、最初以外使わない無駄な領域にはなってしまうが、とりあえずグローバルで確保することにした。
その後、スタックも高位の論理アドレスに確保し、切り替える。

## 第3段階

第2段階においても、0xc0000000までは4MBページングを用いて一様にマップしていたが、これをやめる。
メモリマップを参照し、有効な場所(availableの場所、その他役割がある場所)を
4KBページングでマップする。
ただし、この領域は物理アドレスと同じ論理アドレスでアクセスできるようにしておく。
その方が、物理アドレスへのアクセス用に論理アドレスでビューを確保するなどの複雑な処理をするより、
複雑なことを考えずにすんで良いだろう。
