# 5. 電源を切ろう

これまでのプログラムは、処理終了時に無限ループで処理を止めていました。
そして、仮想マシンを強制終了することで、終了していました。
しかし、やはり正常終了で終了したいものです。
以前は[APM](http://oswiki.osask.jp/?APM)での終了処理を書いていましたが、
これはBIOSに依存していますし、仮想マシンでは動いても(BIOSは使える)実機では動きませんでした。
そこで、今回はACPIを用いて電源を切りたいと思います。

## 情報源

こんな記事がありました。

* [ACPI で電源を切る - 借り初めのひみつきち](https://neriring.hatenablog.jp/entry/2019/03/09/133206)
* [ACPI で電源を切るの補足 - 借り初めのひみつきち](https://neriring.hatenablog.jp/entry/2019/03/11/224418)

やりたいことそのままのようですが、情報が足りなそうです。
具体的なメモリ内のデータも見ながら調べていきましょう。

また、「ACPI specification」でググり、これを見つけました。

* [Advanced Configuration and Power Interface Specification](https://www.intel.com/content/dam/www/public/us/en/documents/articles/acpi-config-power-interface-spec.pdf)

624ページもあるPDFで、ちゃんと読むのはつらそうです。
とりあえず、欲しい情報を得る狙いに絞って見るのがよさそうです。

## メモリの内容をチェック

前回同様にQEMUとGDBを連携させ、自分のプログラムが起動された時点でのメモリの内容を見ていきます。
以下の手順で準備をします。

1. QEMUにおまじない`-S -gdb tcp::9000`をつけて起動する
2. GDBを起動する (以下、GDBでの操作)
3. QEMUに接続する `target remote localhost:9000`
4. 実行開始時点にブレークポイントを置く `break *0x401000`
5. ブレークポイントまで実行する `c`

### `_S5_`を探す

最初の記事を参考に、まずは`_S5_`という名前を探してみます。

```
find /b 0x7f00000,0x8000000,0x5f,0x53,0x35,0x5f
```

すると、`0x7f68c77`の1箇所がヒットしました。
まわりを見てみましょう。

```
(gdb) x/128bx 0x7f68c40
0x7f68c40:      0x53    0x54    0x41    0x0a    0x0b    0x08    0x5f    0x43
0x7f68c48:      0x52    0x53    0x11    0x0d    0x0a    0x0a    0x47    0x01
0x7f68c50:      0x00    0xae    0x00    0xae    0x01    0x14    0x79    0x00
0x7f68c58:      0x10    0x29    0x5c    0x00    0x08    0x5f    0x53    0x33
0x7f68c60:      0x5f    0x12    0x06    0x04    0x01    0x01    0x00    0x00
0x7f68c68:      0x08    0x5f    0x53    0x34    0x5f    0x12    0x08    0x04
0x7f68c70:      0x0a    0x02    0x0a    0x02    0x00    0x00    0x08    0x5f
0x7f68c78:      0x53    0x35    0x5f    0x12    0x06    0x04    0x00    0x00
0x7f68c80:      0x00    0x00    0x10    0x3b    0x5c    0x2e    0x5f    0x53
0x7f68c88:      0x42    0x5f    0x50    0x43    0x49    0x30    0x5b    0x82
0x7f68c90:      0x2e    0x46    0x57    0x43    0x46    0x08    0x5f    0x48
0x7f68c98:      0x49    0x44    0x0d    0x51    0x45    0x4d    0x55    0x30
0x7f68ca0:      0x30    0x30    0x32    0x00    0x08    0x5f    0x53    0x54
0x7f68ca8:      0x41    0x0a    0x0b    0x08    0x5f    0x43    0x52    0x53
0x7f68cb0:      0x11    0x0d    0x0a    0x0a    0x47    0x01    0x10    0x05
0x7f68cb8:      0x10    0x05    0x01    0x0c    0x79    0x00    0x10    0x45
```

うーん…？これだけ見てもよくわかりません。次に進みます。

### EFI System Table?

2番目の記事を見ると、何かのテーブルから指定のGUIDを探すと吉のようです。
早速探します。
記事を参考に、リトルエンディアンであることに注意してクエリを指定します。

```
find /b 0x7f00000,0x8000000,0x71,0xe8,0x68,0x88,0xf1,0xe4,0xd3,0x11,0xbc,0x22,0x00,0x80,0xc7,0x3c,0x88,0x81
```

すると、`0x7f5f130`の1箇所がヒットしました。
また、このテーブルはなにかの引数で指定されるようです。
スタックポインタのまわりの値を見てみましょう。

```
(gdb) x/12xw $esp
0x7f90db0:      0x07f949b1      0x07568150      0x07f5f010      0x0756c5d0
0x7f90dc0:      0x0756c5d0      0x000000ed      0x00000000      0x00000000
0x7f90dd0:      0x00000000      0x00000000      0x0756ccd0      0x07f90e4c
```

この中では、`0x07f5f010`が一番見つかったGUIDの位置に近いです。
これは、4バイトの引数なら2個目に相当しそうですね。
まわりを見てみましょう。

```
(gdb) x/384xb 0x7f5f000
0x7f5f000:      0x70    0x68    0x64    0x30    0xaf    0xaf    0xaf    0xaf
0x7f5f008:      0x06    0x00    0x00    0x00    0x64    0x00    0x00    0x00
0x7f5f010:      0x49    0x42    0x49    0x20    0x53    0x59    0x53    0x54
0x7f5f018:      0x32    0x00    0x02    0x00    0x48    0x00    0x00    0x00
0x7f5f020:      0x19    0x79    0x3f    0xe8    0x00    0x00    0x00    0x00
0x7f5f028:      0x50    0xcf    0xf3    0x07    0x00    0x00    0x01    0x00
0x7f5f030:      0xd0    0x4d    0x69    0x07    0xcc    0x46    0xde    0x07
0x7f5f038:      0x90    0x3f    0x69    0x07    0x0c    0x46    0xde    0x07
0x7f5f040:      0xd0    0x3e    0x69    0x07    0x4c    0x45    0xde    0x07
0x7f5f048:      0x90    0xff    0xf5    0x07    0x80    0xad    0xfa    0x07
0x7f5f050:      0x09    0x00    0x00    0x00    0x90    0xf0    0xf5    0x07
0x7f5f058:      0x70    0x74    0x61    0x6c    0xaf    0xaf    0xaf    0xaf
0x7f5f060:      0x64    0x00    0x00    0x00    0xaf    0xaf    0xaf    0xaf
0x7f5f068:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f070:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f078:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f080:      0x70    0x68    0x64    0x30    0x08    0x00    0x00    0x00
0x7f5f088:      0x06    0x00    0x00    0x00    0x5c    0x01    0x00    0x00
0x7f5f090:      0x98    0x58    0x4e    0xee    0x14    0x39    0x59    0x42
0x7f5f098:      0x9d    0x6e    0xdc    0x7b    0xd7    0x94    0x03    0xcf
0x7f5f0a0:      0x10    0xbf    0xd8    0x07    0xba    0x34    0xad    0x05
0x7f5f0a8:      0x02    0x6f    0x14    0x42    0x95    0x2e    0x4d    0xa0
0x7f5f0b0:      0x39    0x8e    0x2b    0xb9    0x00    0xad    0xfa    0x07
0x7f5f0b8:      0x4c    0xf2    0x39    0x77    0xd7    0x93    0xd4    0x11
0x7f5f0c0:      0x9a    0x3a    0x00    0x90    0x27    0x3f    0xc1    0x4d
0x7f5f0c8:      0x10    0x80    0xd8    0x07    0x9f    0x04    0x19    0x4c
0x7f5f0d0:      0x37    0x41    0xd3    0x4d    0x9c    0x10    0x8b    0x97
0x7f5f0d8:      0xa8    0x3f    0xfd    0xfa    0x40    0xd1    0xfa    0x07
0x7f5f0e0:      0x77    0x2e    0x15    0x49    0xda    0x1a    0x64    0x47
0x7f5f0e8:      0xb7    0xa2    0x7a    0xfe    0xfe    0xd9    0x5e    0x8b
0x7f5f0f0:      0xd8    0xb6    0xfa    0x07    0x31    0x2d    0x9d    0xeb
0x7f5f0f8:      0x88    0x2d    0xd3    0x11    0x9a    0x16    0x00    0x90
0x7f5f100:      0x27    0x3f    0xc1    0x4d    0x00    0x00    0xf4    0x07
0x7f5f108:      0x44    0x15    0xfd    0xf2    0x94    0x97    0x2c    0x4a
0x7f5f110:      0x99    0x2e    0xe5    0xbb    0xcf    0x20    0xe3    0x94
0x7f5f118:      0x00    0xe0    0xf3    0x07    0x30    0x2d    0x9d    0xeb
0x7f5f120:      0x88    0x2d    0xd3    0x11    0x9a    0x16    0x00    0x90
0x7f5f128:      0x27    0x3f    0xc1    0x4d    0x00    0xb0    0xf6    0x07
0x7f5f130:      0x71    0xe8    0x68    0x88    0xf1    0xe4    0xd3    0x11
0x7f5f138:      0xbc    0x22    0x00    0x80    0xc7    0x3c    0x88    0x81
0x7f5f140:      0x14    0xb0    0xf6    0x07    0xaf    0xaf    0xaf    0xaf
0x7f5f148:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f150:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f158:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f160:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f168:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f170:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
0x7f5f178:      0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf    0xaf
```

もしこれが何らかの構造体の配列であるとすれば、等間隔で構造体(とそのメンバ)が配置され、
メンバの1つと推測できるGUIDも等間隔に配置されると予想できます。
[UUID - Wikipedia](https://ja.wikipedia.org/wiki/UUID)、及び記事中のGUIDの表記を参考にすると、
GUIDの7バイト目(0-origin)の16進数での上位がバージョンを示すので1～5のいずれか、
8バイト目(0-origin)の16進数での上位がバリアントを示すので8～bのいずれかになる、
ということがわかります。
今回ダンプした範囲からこの条件に合う位置を探すと、以下がヒットしました。

```
ヒット位置  ヒット位置-7  ヒットデータ
0x7f5f003   0x7f5effc     0x30 0xaf
0x7f5f097   0x7f5f090     0x42 0x9d
0x7f5f0a0   0x7f5f099     0x10 0xbf
0x7f5f0a5   0x7f5f09e     0x34 0xad
0x7f5f0ab   0x7f5f0a4     0x42 0x95
0x7f5f0ae   0x7f5f0a7     0x4d 0xa0
0x7f5f0b0   0x7f5f0a9     0x39 0x8e
0x7f5f0b2   0x7f5f0ab     0x2b 0xb9
0x7f5f0bf   0x7f5f0b8     0x11 0x9a
0x7f5f0c8   0x7f5f0c1     0x10 0x80
0x7f5f0d3   0x7f5f0cc     0x4d 0x9c
0x7f5f0d5   0x7f5f0ce     0x10 0x8b
0x7f5f0e7   0x7f5f0e0     0x47 0xb7
0x7f5f0ee   0x7f5f0e7     0x5e 0x8b
0x7f5f0f5   0x7f5f0ee     0x2d 0x9d
0x7f5f0fb   0x7f5f0f4     0x11 0x9a
0x7f5f10f   0x7f5f108     0x4a 0x99
0x7f5f11d   0x7f5f016     0x2d 0x9d
0x7f5f123   0x7f5f11c     0x11 0x9a
0x7f5f137   0x7f5f130     0x11 0xbc
0x7f5f13d   0x7f5f136     0x3c 0x88
0x7f5f140   0x7f5f139     0x14 0xb0
```

ちょっと多いので、用途が特殊なバージョン2,3,5を除き、バージョン1,4に絞ってみます。

```
ヒット位置  ヒット位置-7  ヒットデータ
0x7f5f097   0x7f5f090     0x42 0x9d
0x7f5f0a0   0x7f5f099     0x10 0xbf
0x7f5f0ab   0x7f5f0a4     0x42 0x95
0x7f5f0ae   0x7f5f0a7     0x4d 0xa0
0x7f5f0bf   0x7f5f0b8     0x11 0x9a
0x7f5f0c8   0x7f5f0c1     0x10 0x80
0x7f5f0d3   0x7f5f0cc     0x4d 0x9c
0x7f5f0d5   0x7f5f0ce     0x10 0x8b
0x7f5f0e7   0x7f5f0e0     0x47 0xb7
0x7f5f0fb   0x7f5f0f4     0x11 0x9a
0x7f5f10f   0x7f5f108     0x4a 0x99
0x7f5f123   0x7f5f11c     0x11 0x9a
0x7f5f137   0x7f5f130     0x11 0xbc
0x7f5f140   0x7f5f139     0x14 0xb0
```

このうち、`0x7f5f130`は記事中のGUID、つまり本物である。
そもそもこれがテーブルの最初の要素だと役に立たないが、
そうではないとすると、この前にも本物のGUIDがあるはずである。
とりあえず、4バイトアラインメントを仮定して絞り込んでみます。
さらに、オフセットも追加してみます。

```
ヒット位置  ヒット位置-7  ヒットデータ  オフセット
0x7f5f097   0x7f5f090     0x42 0x9d     -0xa0 (-160)
0x7f5f0ab   0x7f5f0a4     0x42 0x95     -0x8c (-140)
0x7f5f0bf   0x7f5f0b8     0x11 0x9a     -0x78 (-120)
0x7f5f0d3   0x7f5f0cc     0x4d 0x9c     -0x64 (-100)
0x7f5f0e7   0x7f5f0e0     0x47 0xb7     -0x50 ( -80)
0x7f5f0fb   0x7f5f0f4     0x11 0x9a     -0x3c ( -60)
0x7f5f10f   0x7f5f108     0x4a 0x99     -0x28 ( -40)
0x7f5f123   0x7f5f11c     0x11 0x9a     -0x14 ( -20)
0x7f5f137   0x7f5f130     0x11 0xbc      0x00 (  -0)
```

なんということでしょう。きれいに20バイトごとになっていました。
同じ範囲をワード単位でダンプしなおしてみます。

```
(gdb) x/96xw 0x7f5f000
0x7f5f000:      0x30646870      0xafafafaf      0x00000006      0x00000064
0x7f5f010:      0x20494249      0x54535953      0x00020032      0x00000048
0x7f5f020:      0xe83f7919      0x00000000      0x07f3cf50      0x00010000
0x7f5f030:      0x07694dd0      0x07de46cc      0x07693f90      0x07de460c
0x7f5f040:      0x07693ed0      0x07de454c      0x07f5ff90      0x07faad80
0x7f5f050:      0x00000009      0x07f5f090      0x6c617470      0xafafafaf
0x7f5f060:      0x00000064      0xafafafaf      0xafafafaf      0xafafafaf
0x7f5f070:      0xafafafaf      0xafafafaf      0xafafafaf      0xafafafaf
0x7f5f080:      0x30646870      0x00000008      0x00000006      0x0000015c
0x7f5f090:      0xee4e5898      0x42593914      0x7bdc6e9d      0xcf0394d7
0x7f5f0a0:      0x07d8bf10      0x05ad34ba      0x42146f02      0xa04d2e95
0x7f5f0b0:      0xb92b8e39      0x07faad00      0x7739f24c      0x11d493d7
0x7f5f0c0:      0x90003a9a      0x4dc13f27      0x07d88010      0x4c19049f
0x7f5f0d0:      0x4dd34137      0x978b109c      0xfafd3fa8      0x07fad140
0x7f5f0e0:      0x49152e77      0x47641ada      0xfe7aa2b7      0x8b5ed9fe
0x7f5f0f0:      0x07fab6d8      0xeb9d2d31      0x11d32d88      0x9000169a
0x7f5f100:      0x4dc13f27      0x07f40000      0xf2fd1544      0x4a2c9794
0x7f5f110:      0xbbe52e99      0x94e320cf      0x07f3e000      0xeb9d2d30
0x7f5f120:      0x11d32d88      0x9000169a      0x4dc13f27      0x07f6b000
0x7f5f130:      0x8868e871      0x11d3e4f1      0x800022bc      0x81883cc7
0x7f5f140:      0x07f6b014      0xafafafaf      0xafafafaf      0xafafafaf
0x7f5f150:      0xafafafaf      0xafafafaf      0xafafafaf      0xafafafaf
0x7f5f160:      0xafafafaf      0xafafafaf      0xafafafaf      0xafafafaf
0x7f5f170:      0xafafafaf      0xafafafaf      0xafafafaf      0xafafafaf
```

`0x7f5f0a0`から、5ワードおきに`0x07`で始まるワードがある様子が見て取れます。
したがって、ここは16バイトのGUIDと4バイトのアドレスが組になった構造体のテーブルであると推測できます。

さらに、その前の`0x7f5f050`にこのテーブル(仮)のアドレスである`0x7f5f090`が、
`0x7f5f050`にこのテーブル(仮)の要素数(推測)である`0x00000009`があります。
これらは、それぞれ記事中の`st->ConfigurationTable`と`st->NumberOfTableEntries`に相当すると推測できます。

### RSDP (仮)

これまでの推測に基づくと、見つかったGUIDの次にある`0x07f6b014`がRSDPのアドレスであると推測できます。
内容を見てみましょう。
なお、RSDPの構造は記事に書かれています。助かります。

```
(gdb) x/9xw 0x07f6b014
0x7f6b014:      0x20445352      0x20525450      0x434f423f      0x02205348
0x7f6b024:      0x07f6a074      0x00000024      0x07f6a0e8      0x00000000
0x7f6b034:      0x00000057
```

分解すると

```
signature : 0x52,0x53,0x44,0x20,0x50,0x54,0x52,0x20 (RSD PTR )
checksum  : 0x3f
oemid     : 0x42,0x4f,0x43,0x48,0x53,0x20 (BOCHS )
revision  : 0x02
rsdtaddr  : 0x07f6a074
length    : 0x00000024
xsdtaddr  : 0x0000000007f6a0e8
checksum2 : 0x57
reserved  : 0x00,0x00,0x00
```

となります。
これでRSDTとXSDTのアドレスが得られました。
記事ではXSDTを使えと書かれていますが、XSDTはRSDTを64bitに拡張したものとのことです。
今回は32bit環境を対象としているのに、なぜ64bitを使うべきなのでしょうか？
とりあえず、一旦飛ばして次のテーブルをサーチします。

### FADT - 捜索編

記事によれば、次はシグネチャ`FACP`のテーブルを見ると良さそうです。
サーチします。

```
(gdb) find /b 0x7f00000,0x8000000,0x46,0x41,0x43,0x50
0x7f67000
0x7f67014
0x7f6a014
0x7f6a088
0x7f6a0fc
```

おっ、5件出てきました。
本物のアドレスはRSDTやXSDTにかかれているはずです。
飛ばしていたRSDTやXSDTをダンプしてみましょう。
なお、テーブルの先頭のHeaderの長さは9ワードです。

```
(gdb) x/64xw 0x07f6a074
0x7f6a074:      0x54445352      0x00000034      0x4f42cf01      0x20534843
0x7f6a084:      0x43505842      0x50434146      0x00000001      0x20202020
0x7f6a094:      0x01000013      0x07f67000      0x07f66000      0x07f65000
0x7f6a0a4:      0x07f64000      0x00000000      0x00000000      0x00000000
0x7f6a0b4:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a0c4:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a0d4:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a0e4:      0x00000000      0x54445358      0x00000044      0x4f42b901
0x7f6a0f4:      0x20534843      0x43505842      0x50434146      0x00000001
0x7f6a104:      0x20202020      0x01000013      0x07f67000      0x00000000
0x7f6a114:      0x07f66000      0x00000000      0x07f65000      0x00000000
0x7f6a124:      0x07f64000      0x00000000      0x00000000      0x00000000
0x7f6a134:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a144:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a154:      0x00000000      0x00000000      0x00000000      0x00000000
0x7f6a164:      0x00000000      0x00000000      0x00000000      0x00000000
```

あっ、この環境ではRSDTとXSDTが近かったので、1回のダンプで両方出てきました。
RSDTとXSDT、それぞれ4個のアドレスが書かれているようです。
よく見ると、この環境のXSDTではアドレスの上位に0x00000000が入っているだけで、
両方とも順番を含めて同じアドレスの列が書かれています。
基本はRSDTを使い、RSDTでの検索に失敗したらXSDTを使えば良いと推測できます。

先程出た`FACP`のアドレスのうち、ここに載っているのは``0x7f67000`だけです。
一応他の部分も見てみましょう。

```
(gdb) x/4xw 0x7f67000
0x7f67000:      0x50434146      0x00000074      0x4f425901      0x20534843
(gdb) x/4xw 0x7f67014
0x7f67014:      0x50434146      0x00000001      0x43505842      0x00000001
(gdb) x/4xw 0x7f6a014
0x7f6a014:      0x50434146      0x00000001      0x20202020      0x01000013
(gdb) x/4xw 0x7f6a088
0x7f6a088:      0x50434146      0x00000001      0x20202020      0x01000013
(gdb) x/4xw 0x7f6a0fc
0x7f6a0fc:      0x50434146      0x00000001      0x20202020      0x01000013
```

RSDT/XSDTに乗っていたアドレスではHeaderのlengthに当たる部分に0x00000074が入っていますが、
他のアドレスにでは0x00000001が入っており、テーブルのサイズとして不適と考えられます。

### FADT - 中身編

得られたアドレス0x7f67000をダンプします。

```
(gdb) x/29xw 0x7f67000
0x7f67000:      0x50434146      0x00000074      0x4f425901      0x20534843
0x7f67010:      0x43505842      0x50434146      0x00000001      0x43505842
0x7f67020:      0x00000001      0x07f6d000      0x07f68000      0x00090001
0x7f67030:      0x000000b2      0x0000f0f1      0x0000b000      0x00000000
0x7f67040:      0x0000b004      0x00000000      0x00000000      0x0000b008
0x7f67050:      0x0000afe0      0x00000000      0x04000204      0x00000004
0x7f67060:      0x0fff0fff      0x00000000      0x00000000      0x00000032
0x7f67070:      0x000080a5
```

記事によればここにDSDTというテーブルがあるらしいですが、これではよくわかりません。
とりあえず`DSDT`をサーチします。

```
(gdb) find /b 0x7f00000,0x8000000,0x44,0x53,0x44,0x54
0x7f68000
0x7f68014
```

2件ヒットしました。このうち`0x07f68000`はFADTのデータに入っています。
…というか、このテーブルには`0x07`で始まらないデータが多く、
単純に探索するべきではなさそうな気がします。
ここで、Advanced Configuration and Power Interface Specificationを参照すると、
5.2.9   Fixed ACPI Description Table (FADT)にFADTの中身の情報がありました。
これによるとByte Offset 40がDSDTであるとのことで、これは観察結果と一致します。
ついでに、ここには後で使う以下の情報もあるようです。

```
名前          Byte Offset  値
SMI_CMD       48           0x000000b2
ACPI_ENABLE   52           0xf1
PM1a_CNT_BLK  64           0x0000b004
PM1b_CNT_BLK  68           0x00000000
```

### DSDT

得られたDSDTのアドレスをダンプします。

```
(gdb) x/32xw 0x7f68000
0x7f68000:      0x54445344      0x000013c4      0x4f42e201      0x20534843
0x7f68010:      0x43505842      0x54445344      0x00000001      0x43505842
0x7f68020:      0x00000001      0x5c044910      0x44805b00      0x015f4742
0x7f68030:      0x0104020b      0x440b815b      0x015f4742      0x42474244
0x7f68040:      0x442c1408      0x01475542      0x96606898      0x87746060
0x7f68050:      0x70610160      0x10a26200      0x70616295      0x62608883
0x7f68060:      0x47424400      0x70627542      0x42440a0a      0x22104247
0x7f68070:      0x5f42535f      0x501b825b      0x08304943      0x4449485f
```

うーん…よくわかりません。記事で紹介されているAMLとやらでしょうか？
それにしては、最初のバイト0x10から意味がわかりません。

Advanced～の5.2.11.1   Differentiated System Description Table (DSDT)を見ると、
36バイト目からはDefinition Blockとなっており、やはりAMLのようです。

### AML

とりあえず長めにダンプします。

```
(gdb) x/512xb 0x7f68024
0x7f68024:      0x10    0x49    0x04    0x5c    0x00    0x5b    0x80    0x44
0x7f6802c:      0x42    0x47    0x5f    0x01    0x0b    0x02    0x04    0x01
0x7f68034:      0x5b    0x81    0x0b    0x44    0x42    0x47    0x5f    0x01
0x7f6803c:      0x44    0x42    0x47    0x42    0x08    0x14    0x2c    0x44
0x7f68044:      0x42    0x55    0x47    0x01    0x98    0x68    0x60    0x96
0x7f6804c:      0x60    0x60    0x74    0x87    0x60    0x01    0x61    0x70
0x7f68054:      0x00    0x62    0xa2    0x10    0x95    0x62    0x61    0x70
0x7f6805c:      0x83    0x88    0x60    0x62    0x00    0x44    0x42    0x47
0x7f68064:      0x42    0x75    0x62    0x70    0x0a    0x0a    0x44    0x42
0x7f6806c:      0x47    0x42    0x10    0x22    0x5f    0x53    0x42    0x5f
0x7f68074:      0x5b    0x82    0x1b    0x50    0x43    0x49    0x30    0x08
0x7f6807c:      0x5f    0x48    0x49    0x44    0x0c    0x41    0xd0    0x0a
0x7f68084:      0x03    0x08    0x5f    0x41    0x44    0x52    0x00    0x08
0x7f6808c:      0x5f    0x55    0x49    0x44    0x00    0x10    0x4d    0x08
0x7f68094:      0x5f    0x53    0x42    0x5f    0x5b    0x82    0x45    0x08
0x7f6809c:      0x48    0x50    0x45    0x54    0x08    0x5f    0x48    0x49
0x7f680a4:      0x44    0x0c    0x41    0xd0    0x01    0x03    0x08    0x5f
0x7f680ac:      0x55    0x49    0x44    0x00    0x5b    0x80    0x48    0x50
0x7f680b4:      0x54    0x4d    0x00    0x0c    0x00    0x00    0xd0    0xfe
0x7f680bc:      0x0b    0x00    0x04    0x5b    0x81    0x10    0x48    0x50
0x7f680c4:      0x54    0x4d    0x13    0x56    0x45    0x4e    0x44    0x20
0x7f680cc:      0x50    0x52    0x44    0x5f    0x20    0x14    0x36    0x5f
0x7f680d4:      0x53    0x54    0x41    0x00    0x70    0x56    0x45    0x4e
0x7f680dc:      0x44    0x60    0x70    0x50    0x52    0x44    0x5f    0x61
0x7f680e4:      0x7a    0x60    0x0a    0x10    0x60    0xa0    0x0c    0x91
0x7f680ec:      0x93    0x60    0x00    0x93    0x60    0x0b    0xff    0xff
0x7f680f4:      0xa4    0x00    0xa0    0x0e    0x91    0x93    0x61    0x00
0x7f680fc:      0x94    0x61    0x0c    0x00    0xe1    0xf5    0x05    0xa4
0x7f68104:      0x00    0xa4    0x0a    0x0f    0x08    0x5f    0x43    0x52
0x7f6810c:      0x53    0x11    0x11    0x0a    0x0e    0x86    0x09    0x00
0x7f68114:      0x00    0x00    0x00    0xd0    0xfe    0x00    0x04    0x00
0x7f6811c:      0x00    0x79    0x00    0x10    0x26    0x2e    0x5f    0x53
0x7f68124:      0x42    0x5f    0x50    0x43    0x49    0x30    0x5b    0x82
0x7f6812c:      0x1a    0x49    0x53    0x41    0x5f    0x08    0x5f    0x41
0x7f68134:      0x44    0x52    0x0c    0x00    0x00    0x01    0x00    0x5b
0x7f6813c:      0x80    0x50    0x34    0x30    0x43    0x02    0x0a    0x60
0x7f68144:      0x0a    0x04    0x10    0x4e    0x17    0x2f    0x03    0x5f
0x7f6814c:      0x53    0x42    0x5f    0x50    0x43    0x49    0x30    0x49
0x7f68154:      0x53    0x41    0x5f    0x5b    0x82    0x34    0x4b    0x42
0x7f6815c:      0x44    0x5f    0x08    0x5f    0x48    0x49    0x44    0x0c
0x7f68164:      0x41    0xd0    0x03    0x03    0x08    0x5f    0x53    0x54
0x7f6816c:      0x41    0x0a    0x0f    0x08    0x5f    0x43    0x52    0x53
0x7f68174:      0x11    0x18    0x0a    0x15    0x47    0x01    0x60    0x00
0x7f6817c:      0x60    0x00    0x01    0x01    0x47    0x01    0x64    0x00
0x7f68184:      0x64    0x00    0x01    0x01    0x22    0x02    0x00    0x79
0x7f6818c:      0x00    0x5b    0x82    0x24    0x4d    0x4f    0x55    0x5f
0x7f68194:      0x08    0x5f    0x48    0x49    0x44    0x0c    0x41    0xd0
0x7f6819c:      0x0f    0x13    0x08    0x5f    0x53    0x54    0x41    0x0a
0x7f681a4:      0x0f    0x08    0x5f    0x43    0x52    0x53    0x11    0x08
0x7f681ac:      0x0a    0x05    0x22    0x00    0x10    0x79    0x00    0x5b
0x7f681b4:      0x82    0x41    0x08    0x46    0x44    0x43    0x30    0x08
0x7f681bc:      0x5f    0x48    0x49    0x44    0x0c    0x41    0xd0    0x07
0x7f681c4:      0x00    0x08    0x5f    0x43    0x52    0x53    0x11    0x1b
0x7f681cc:      0x0a    0x18    0x47    0x01    0xf2    0x03    0xf2    0x03
0x7f681d4:      0x00    0x04    0x47    0x01    0xf7    0x03    0xf7    0x03
0x7f681dc:      0x00    0x01    0x22    0x40    0x00    0x2a    0x04    0x00
0x7f681e4:      0x79    0x00    0x5b    0x82    0x31    0x46    0x4c    0x50
0x7f681ec:      0x41    0x08    0x5f    0x41    0x44    0x52    0x00    0x08
0x7f681f4:      0x5f    0x46    0x44    0x49    0x12    0x20    0x10    0x00
0x7f681fc:      0x0a    0x04    0x0a    0x52    0x0a    0x18    0x01    0x0a
0x7f68204:      0xaf    0x0a    0x02    0x0a    0x25    0x0a    0x02    0x0a
0x7f6820c:      0x12    0x0a    0x1b    0x0a    0xff    0x0a    0x6c    0x0a
0x7f68214:      0xf6    0x0a    0x0f    0x0a    0x08    0x08    0x5f    0x46
0x7f6821c:      0x44    0x45    0x11    0x17    0x0a    0x14    0x01    0x00
```

意味の推測は難しそうなので、Advanced～の18   ACPI Machine Language (AML) Specificationを参照します。

まず、AMLの実体はTermList(TermObjの列)のようです。
最初の0x10はScopeOpを表し、PkgLength、NameString、TermListが続きます。
PkgLengthは最初の2ビットで長さがわかり、今回は`0x49 0x04`で長さ0x49を表しているようです。
NameStringは、今回は`0x5c 0x00`が該当しそうです。
次は`0x5b 0x80`でOpRegionOpを表し…

うーん、諦めて記事の通り`08 5F 53 35 5F 12`のパターンを探すのが良さそうです。

0x08はNameOpであり、NameStringとDataRefObjectが続きます。

NameStringの最初はRootCharかPrefixPathであり、今回はPrefixPathのうちのNothingのようです。
PrefixPathの次はNamePathであり、0x5fで始まるのはNameSegです。
これは4バイトのデータなので、最初の`08`がNameOpを表すと仮定すれば、
NameStringは`5F 53 35 5F`の部分だとわかります。

DataRefObjectの一つがDataObjectであり、DataObjectの一つがDefPackageです。
DefPackageはPackageOp、すなわち0x12から始まります。
さらに、PkgLength、NumElements、PackageElementListと続きます。
PkgLengthは1～4バイトで、記事も参照するとこれを含む長さを表すようです。
NumElementsは1バイトです。
PackageElementListはPackageElementの列で、PackageElementはDataRefObjectまたはNameStringです。
DataRefObjectであるDataObjectの一種にComputationalDataがあります。
ComputationalDataには、ConstObj、ByteConstなどがあります。
`0x00`は、ConstObjの一つであるZeroOpです。
ByteConstは、BytePrefix、すなわち`0x0A`とByteData、すなわち1バイトのデータからなります。

うーん…とりあえず、以下のように処理すればよさそうです。

1. AMLの範囲からパターン`08 5F 53 35 5F 12`を探す。
   見つからなかったり、複数見つかったら、諦める。
2. `0x12`の次のバイトを読み、データの長さとする。
   このとき、`0x40`以上の値だったら、諦める。 (複数バイトのPkgLengthは諦める)
3. その次のバイトを読み、要素数とする。これはただの1バイトである。
4. 次から要素数のデータを読む。データの長さと矛盾しないように注意する。
   * `0x00` (ZeroOP) であれば、データに0を追加する。
   * `0x0A` (ByteConstのBytePrefix) であれば、データにその次のバイト(ByteData)を追加する。
   * その他であれば、諦める。

また、Advanced～のTable 7-11 System State Packageを見ると、
最初のバイトが`PM1a_CNT.SLP_TYP`に書き込むべき値、
次のバイトが`PM1b_CNT.SLP_TYP`に書き込むべき値のようです。

## PM1 Control Registers

Advanced～のTable 4-13   PM1 Control Registers Fixed Hardware Feature Control Bitsを参照します。
このレジスタは16ビットのようです。

0ビット目は`SCI_EN`です。
記事によれば、`SMI_CMD`に`ACPI_ENABLE`を書き込んだ後、
このビットが1になるのを確認しないといけないようです。
1になっているとSCI interruptが発生するようですが、今はよくわかりません。

10ビット目～12ビット目が`SLP_TYPx`です。
`_S5_`から取得した値をここに書き込むようです。

13ビット目は`SLP_EN`です。1を書き込むと`SLP_TYPX`に書き込んだ値に基づいたスリープに入るようです。

Reservedなど他のデータもあるので、一回読んで必要なビットだけ書き換えてから書き戻す方がよさそうな気がします。

## まとめ

以下、「n番目」「nワード目」は0-originです。

### 必要なデータを得る

1. UEFIから自分のプログラムを起動してもらう
2. 4バイトの引数2個目を取得する。これを4バイトの値の配列の先頭要素へのポインタと仮定する。
3. この配列の17番目の要素をGUIDテーブルの先頭要素へのポインタ、
   16番目の要素をGUIDテーブルの要素数とする。
   ただし、GUIDテーブルとは、16バイトのGUIDと4バイトのアドレスがこの順番で格納された構造体を要素とするテーブルである。
4. GUIDテーブルからGUIDがバイト列`0x71,0xe8,0x68,0x88,0xf1,0xe4,0xd3,0x11,0xbc,0x22,0x00,0x80,0xc7,0x3c,0x88,0x81`になっているものを探す。
   見つかった要素に格納されているアドレスをRSDPのアドレスとする。
5. RSDPの4ワード目をRSDTのアドレスとする。
6. RSDTの1ワード目に格納されているRSDTのサイズを超えないようにしつつ、
   RSDTの9ワード目以降のワードから指している先が"FACP"となっているものを探す。
   見つかったワードをFADTのアドレスとする。
7. FADTの10ワード目をDSDTのアドレスとする。
   また、12ワード目を`SMI_CMD`、13ワード目の下位1バイトを`ACPI_ENABLE`、
   16ワード目を`PM1a_CNT_BLK`、17ワード目を`PM1b_CNT_BLK`とする。
8. DSDTの1ワード目をDSDTのサイズ(ヘッダを含む)とする。
9. DSDTの36バイト目以降がAMLなので、パターン`08 5F 53 35 5F 12`を探す。
10. ちょうど1個見つかったら、データを読み、最初のデータをPM1a用のデータ、次のデータをPM1b用のデータとする。

### 得たデータを使って電源を切る

1. I/Oポートの`SMI_CMD`に`ACPI_ENABLE`を書き込む。
2. I/Oポートの`PM1a_CNT_BLK`を読み、0ビット目が1になるのを待つ。
3. I/Oポートの`PM1a_CNT_BLK`の10～12ビット目を得たデータ、13ビット目を1に書き換える。
4. `PM1b_CNT_BLK`が0でなければ、
   I/Oポートの`PM1b_CNT_BLK`の10～12ビット目を得たデータ、13ビット目を1に書き換える。

## 実装

ここまでの内容を`05_poweroff.c`として実装した。
実行した結果、QEMUおよびVirtualBoxで仮想マシンが終了する(電源が切れる)ことを確認できた。

## x64対応

x64においては、QEMUで確認した結果、

* 最初の配列の場所は、レジスタEDXで渡される
* GUIDテーブルの先頭要素へのポインタは、最初の配列の28ワード目(0-origin)
* GUIDテーブルの要素数は、最初の配列の26ワード目(0-origin)
* GUIDテーブルでは、各アドレスの後に4バイトの0x00が挿入される

という違いを除いて(すなわち、RSDP以降は)同じデータ構造になっているようである。
