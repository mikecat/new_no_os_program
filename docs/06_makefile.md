# 6. Makefileを整える

これまでは、各プログラムを手動で`gcc`コマンドを打ってコンパイルしていた。
しかし、これだと若干面倒だし、間違えるリスクも有る。
そこで、`Makefile`を用意し、`make`コマンドでコンパイルできるようにした。

## 使用するパーツ

* [トリビアなmakefile入門](http://www.jsk.t.u-tokyo.ac.jp/~k-okada/makefile/)
  * `$@` : ターゲットのファイル名
  * `$^` : 依存するファイル名のリスト
  * `$<` : 最初の依存するファイル名
  * `$*` : ルールの`%`にマッチした部分
* [GNU make 日本語訳(Coop編) - テキスト変形関数](https://www.ecoop.net/coop/translated/GNUMake3.77/make_8.jp.html)
  * `$(subst from,to,text)` : 文字列text中のパターンfromをtoに置換する
  * `$(patsubst pattern,replacement,text)` : リストtextの要素のうちpatternにマッチするものをreplacementに置換する
  * `$(filter pattern,text)` : リストtextの要素のうち、パターンのリストpatternのどれかの要素にマッチするもののみを抽出する
  * `$(basename names)` : リストnamesの各要素の拡張子を除去したリストを返す
  * `$(suffix names)` : リストnamesの各要素の拡張子を抽出したリストを返す
  * `$(addsuffix suffix,names)` : リストnamesの各要素の後ろにsuffixを結合したリストを返す
  * `$(join list1,list2)` : リストlist1とリストlist2の対応する位置の要素を結合したリストを返す
  * `$(word n,text)` : リストtextのn番目(1-origin)の要素を返す

## デバッグとリリースでコンパイルオプションを分ける

デバッグとリリースでは、最適化レベルの違いやデバッグ情報の有無などコンパイルオプションを変えたい。

今回は、デバッグ版のバイナリにはファイル名に`_d`を加え、
これを用いてコンパイルオプションを使い分けるようにした。

リリース版のオブジェクトリスト`OBJS`からデバッグ版のオブジェクトリスト`OBJS_D`は、
以下の方法で作れる。

```
OBJS_D=$(join $(addsuffix _d,$(basename $(OBJS))),$(suffix $(OBJS)))
```

すなわち、「各要素から拡張子を除いて`_d`を加えたもの」と、「各要素の拡張子」を
それぞれ結合することで作れる。

## ページングの有無でエントリポイントを分ける

現在、エントリポイントとして関数`entry`を用いている。
一方、今後ページングへの対応を実装する際、
ライブラリ側にエントリポイントとする関数`entry_paging`を実装することを予定している。

ライブラリにエントリポイントを入れるため、
それを使わずに同じ名前のエントリポイントを使おうとしても名前が衝突してしまう。
したがって、ページングを使うプログラムと使わないプログラムでエントリポイントを変えたい。

これは、以下の方法で実現した。

```
$(word $(patsubst "%",1,$(subst "",2,"$(filter $@,$(TARGETS_NO_PAGING))")),$(ENTRY_NO_PAGING) $(ENTRY_PAGING))
```

まず、`filter`を用いて、
現在のターゲット`$@`がページングを使わないターゲットのリスト`$(TARGETS_NO_PAGING)`に存在するかをチェックする。

存在する場合、`filter`の結果が空でなくなるため、`"$(filter ...)"`は`""`ではなくなる。
よって、`subst`での置換はひっかからず、`patsubst`で`1`に置換される。

一方、存在しない場合、`filter`の結果が空となり、`subst`で`2`に置換される。

この置換結果を`word`の引数に使うことで、パラメータを変えることを実現している。

## ライブラリを更新したら本体もビルドするようにする

今回、ライブラリのデータは`lib`ディレクトリに格納されている。
ここにはメインの`Makefile`とは独立した`Makefile`がある。

```
make -C lib
```

というコマンドで、これを用いてライブラリをビルドできる。

また、ライブラリのバイナリを依存ファイルに入れることで、
「ライブラリのバイナリが更新されたら本体もビルドする」も実現している。

しかし、これだけでは、本体の`Makefile`だけを明示的に使うことで、
「ライブラリのソースコードが更新されたら、ライブラリのバイナリを更新する」ということが実現できない。

今回は、とりあえず

```
make -C lib && make
```

というコマンドを用いることで、明示的にライブラリのmakeも行うようにする、
運用でカバーをする方針とした。
