# 4. メモリ探検

前回は、シリアルポートへの出力と`printf()`という、データを出力する手段を手に入れた。
すると、自分が今置かれている環境の様子が気になってくる。
そこで、レジスタやメモリの値を出力してみたくなる。

その予備実験として、QEMUをgdbを連携させることでも、レジスタやメモリの値を得てみた。

## QEUとgdbの連携

QEMUを起動する時のコマンドラインに`-S -gdb tcp::9000`というおまじないを加えることで、
起動時にgdbの接続を待ってくれる。
gdbを起動し、`target remote localhost:9000`というおまじないを実行することで、
この待っているQEMUに接続することができる。
QEMU側のおまじないはコロンが2個なのに対し、gdb側のおまじないはコロンが1個である。
これらのおまじないは、ここを参考にした。
[QEMUにGDBを繋げてhariboteOSをデバッグする方法 - Yabu.log](https://yuyubu.hatenablog.com/entry/2018/07/17/QEMU%E3%81%ABGDB%E3%82%92%E7%B9%8B%E3%81%92%E3%81%A6hariboteOS%E3%82%92%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95)

以下に、いくつかのgdbの便利なコマンドを示す。

* `c` : 実行を再開する (実行開始時、ブレークポイント、Ctrl+Cで止めた時など)
* `si` : 1命令実行する
* `break *アドレス` : アドレスの命令にブレークポイントを設定する
* `disable ブレークポイント番号` : ブレークポイントを無効化する
* `enable ブレークポイント番号` : ブレークポイントを有効化する
* `symbol ファイル名` : 指定したファイルからシンボルを読み込み、利用する
* `info registers` : 整数レジスタの値一覧を出力する
* `x/数wx アドレス` : 指定したアドレスから(数)個の32bit整数を16進数で出力する
  * 他の出力方法 : [GDB マニュアル - Memory](https://flex.phys.tohoku.ac.jp/texi/gdb-j/gdb-j_41.html)
* `find /b [/表示する結果の最大数] 開始アドレス,終了アドレス,バイト列` : メモリから指定のバイト列を検索する

## プログラム実行開始時のレジスタの値

QEMUで`01_first.exe`を実行し、エントリーポイントの0x401000にブレークポイントを設定し、
ここで止まった時(すなわち、自分のプログラムの実行が開始される時)の
レジスタの値を`info registers`で出力すると、以下のようになった。

```
(gdb) info registers
eax            0x9      9
ecx            0x7568790        123111312
edx            0x756c5d0        123127248
ebx            0x7568790        123111312
esp            0x7f90db0        0x7f90db0
ebp            0x7f90dec        0x7f90dec
esi            0x7568150        123109712
edi            0x7fab480        133870720
eip            0x401000 0x401000
```

これら以外にセグメントレジスタやxmm系のレジスタなども出力されるが、ここでは省略する。

さらに、QEMUに`-m 4G`オプションを追加し、RAMのサイズを4Gバイトに設定して実行すると、
自分のプログラムの実行開始時のレジスタの値は以下のようになった。

```
(gdb) info registers
eax            0x9      9
ecx            0xbf568890       -1084847984
edx            0xbf56c6d0       -1084832048
ebx            0xbf568890       -1084847984
esp            0xbff90db0       0xbff90db0
ebp            0xbff90dec       0xbff90dec
esi            0xbf568d90       -1084846704
edi            0xbffab480       -1074088832
eip            0x401000 0x401000
```

先頭が`0x7`から`0xbf`になり、下位の値の違いも見られるが、同じようなパターンが見える。
従って、これらは何か意味がある値であると予想できる。
さらに、これらの値はRAMの終わり付近のアドレスになるが、
0xc0000000は超えないようになっている、と予想できる。

## RAMの内容 (手動調査)

このRAMを4Gバイトにした状態で、gdbのメモリダンプコマンドを用い、
RAMの内容を調べた。
結果は以下のようになった。
ただし、手作業で適当な間隔で標本をとって調べているので、抜けや誤りがあるかもしれない。

```
0x400000 - 0x400220 : PEヘッダ
exeファイルに基づくデータの終わり - 0x806000 : 0x00埋め
0x806000 - 0x817160 : ?
0x80e000 - 0x810000 : 0xaf埋め
0x810000 - 0x811340 : ?
0x816cd0 - 0x818000 : ?
0x820010 - 0x84b9f0 : ?
0x84b9f0 - 0x900000 : 0xff埋め
0x900000 - 0xc8cbd0 : ?
0xc8cbd0 - 0x12e0090 : 0xff埋め
0x12e0090 - 0x1300000 : 0x00埋め
0x1300000 - 0x1303e70 : ?
0x1303e70 - 0xbc01f370 : 0x00埋め
0xbc01f370 - 0xbc021680 : ?
0xbc021680 - 0xbed83590 : 0x00埋め
0xbed83590 - 0xbee7dbd0 : ?
0xbee7dbd0 - 0xbee8b010 : 0xff埋め
0xbee8b010 - 0xbee8b020 : ?
0xbee8b020 - 0xbee8c000 : 0x00埋め
0xbee8c000 - 0xbfc01000 : 0xaf埋め
0xbfc01000 - 0xbff3f1b0 : ?
0xbff3f1b0 - 0xbff40000 : 0xaf埋め
0xbff40000 - 0xbff40020 : ?
0xbff40020 - 0xbff41000 : 0xaf埋め
0xbff41000 - 0xbff415f0 : ?
0xbff415f0 - 0xbff57010 : 0xff埋め
0xbff57010 - 0xbff57020 : ?
0xbff57020 - 0xbff58000 : 0xaf埋め
0xbff58000 - 0xbff58e40 : ? (0xbffxxxxxが並んでいる)
0xbff58e40 - 0xbff5a000 : 0xaf埋め
```

…埋めだったり謎データだったりで、めんどくさくなった。

## RAMの内容 (プログラムによる調査)

知りたい情報は、将来RAMの適当な場所に情報を保存する時に既存の情報を壊さないかである。
手作業は面倒なので、プログラム(`04_tanken.c`)で調べることにした。
対象範囲はVRAMなどの割り当てがある下位を抜けた0x100000から、
レジスタで得られるRAMの終わりと予想できる場所とする。
ページを意識して4096バイト(0x1000バイト)ごとに区切り、
「全バイトが特定の値」「3/4以上のバイトが特定の値」「その他」に分類する。

…うーん、出力が長い。
デフォルトでもダンプ部分だけで2032行のデータが得られる。
見るのは大変だし、見落としも発生するかもしれない。
同じデータが長く続いていたら省略するようにしよう。
しきい値は…16行以上同じ要約の行が続いたら省略、でいいかな。
(`04_tanken_2.c`)
ダンプ結果は307行になった。まあ見られる程度だろう。
さらに、RAMのサイズを512Mバイト、1Gバイト、4Gバイトに設定した時も、同様の結果が得られた。
RAMのサイズを64Mバイト、32Mバイトに設定した時は、
パターンの一部が他のパターンに重なって結果が少し変わったが、まあ同様の結果が得られた。
RAMのサイズを24Mバイト、16Mバイトに設定した時は、起動に失敗した。
(24Mバイトの時はBoot Failed.が出た。16Mバイトの時は何も出なかった。)

結論としては、RAMが128MBのとき、この環境では以下のような配置になっているようだ。

* 0x00100000～0x007fffff : 空 (exeファイルの内容がロードされる)
* 0x00800000～0x01303fff : 謎
* 0x01304000～0x0401efff : 空 (RAMの容量に合わせて伸びる)
* 0x0401f000～0x04021fff : 謎
* 0x04022000～0x06d4efff : 空？
* 0x06d4f000～0x07ffffff : 謎

## VirtualBoxでの調査

やはり別の環境でも試してみるべきだろう。
例えば、[VirtualBox](https://www.virtualbox.org/)でやってみた。
VirtualBoxでは仮想フロッピーディスクを接続してもなぜか認識しなかったので、
[起動FDイメージをISOイメージに変換するプログラム](http://web.archive.org/web/20190331084424/http://www.geocities.co.jp/SiliconValley-Cupertino/3686/fdtoiso.html)でisoに変換して仮想CDから起動した。
その結果、RAMが128MBのとき、以下のような配置になった。

* 0x00100000～0x02005fff : 空 (exeファイルの内容がロードされる)
* 0x02006000～0x02e03fff : 謎
* 0x02e04000～0x04017fff : 空 (RAMの容量に合わせて伸びる)
* 0x04018000～0x04027fff : 謎
* 0x04028000～0x05ff3fff : 空？
* 0x05ff4000～0x0613bfff : 謎
* 0x0613c000～0x06777fff : 空？
* 0x06778000～0x072fffff : 謎

RAMの中間に1個謎があり、RAMの最後の方にまた謎がある、という点は共通しているが、
中間の謎の位置が違うし、最後の謎の位置もQEMUより手前になっている。

## 結局、使える領域は…？

RAMの中に空でない領域があることはわかったが、現段階で重要性はわからない。
起動時に使っただけで潰していいデータかもしれないし、
潰してはいけない大事なデータかもしれない。
そもそも、RAMではなくメモリマップドI/Oになっている可能性も考えられる。
今の情報を考えると、

1. RAMをスキャンし、読み書きができる領域を判定する
2. 読み書きができる領域のようなら、次に空かを確認する
3. 空のでない領域の端を適当に丸め、空の領域を余裕を持って使えるとして登録する

という作戦が考えられそうだ。
しかし、ここでまた1個懸念がある。
使える空の領域は仮想マシンだから全部0x00になっていたが、
実機では単に未初期化で、ランダムな値が入っている、という可能性がある。
そうなった場合、どうやって判定するべきだろうか？
内容を細かく見て何らかのヒューリスティックで判定する、という作戦になるかもしれない。

## そうだ、メモリマップ、見よう。

UEFI Shellを使うと、`memmap`コマンドでメモリマップを出力することができる。
QEMUでは、[Index of /repos](https://www.kraxel.org/repos/)のOVMFについている`UefiShell.iso`から起動する。
VirtualBoxでは、ディスクを接続せずに起動することで起動できる。

QEUでの実行結果は、以下のようになった。

```
Type       Start            End              # Pages          Attributes
BS_Code    0000000000000000-0000000000000FFF 0000000000000001 000000000000000F
Available  0000000000001000-000000000009FFFF 000000000000009F 000000000000000F
Available  0000000000100000-0000000000805FFF 0000000000000706 000000000000000F
ACPI_NVS   0000000000806000-0000000000807FFF 0000000000000002 000000000000000F
Available  0000000000808000-000000000080FFFF 0000000000000008 000000000000000F
ACPI_NVS   0000000000810000-00000000008FFFFF 00000000000000F0 000000000000000F
BS_Data    0000000000900000-00000000010FFFFF 0000000000000800 000000000000000F
Available  0000000001100000-0000000003FFFFFF 0000000000002F00 000000000000000F
BS_Data    0000000004000000-000000000401FFFF 0000000000000020 000000000000000F
Available  0000000004020000-0000000006C7FFFF 0000000000002C60 000000000000000F
LoaderCode 0000000006C80000-0000000006D4EFFF 00000000000000CF 000000000000000F
ACPI_NVS   0000000006D4F000-0000000006D5DFFF 000000000000000F 000000000000000F
Reserved   0000000006D5E000-0000000006D6CFFF 000000000000000F 000000000000000F
ACPI_NVS   0000000006D6D000-0000000006D70FFF 0000000000000004 000000000000000F
Reserved   0000000006D71000-0000000006D78FFF 0000000000000008 000000000000000F
BS_Code    0000000006D79000-0000000006E7AFFF 0000000000000102 000000000000000F
RT_Data    0000000006E7B000-0000000006E8BFFF 0000000000000011 800000000000000F
Available  0000000006E8C000-00000000073D7FFF 000000000000054C 000000000000000F
BS_Data    00000000073D8000-00000000074A8FFF 00000000000000D1 000000000000000F
Available  00000000074A9000-00000000074BAFFF 0000000000000012 000000000000000F
BS_Data    00000000074BB000-00000000074D8FFF 000000000000001E 000000000000000F
Available  00000000074D9000-00000000074F3FFF 000000000000001B 000000000000000F
BS_Data    00000000074F4000-00000000074F5FFF 0000000000000002 000000000000000F
Available  00000000074F6000-00000000074F6FFF 0000000000000001 000000000000000F
BS_Data    00000000074F7000-0000000007D8BFFF 0000000000000895 000000000000000F
Available  0000000007D8C000-0000000007D8CFFF 0000000000000001 000000000000000F
BS_Code    0000000007D8D000-0000000007F0BFFF 000000000000017F 000000000000000F
RT_Code    0000000007F0C000-0000000007F3BFFF 0000000000000030 800000000000000F
RT_Data    0000000007F3C000-0000000007F5FFFF 0000000000000024 800000000000000F
Reserved   0000000007F60000-0000000007F63FFF 0000000000000004 000000000000000F
ACPI_Recl  0000000007F64000-0000000007F6BFFF 0000000000000008 000000000000000F
ACPI_NVS   0000000007F6C000-0000000007F6FFFF 0000000000000004 000000000000000F
BS_Data    0000000007F70000-0000000007FCFFFF 0000000000000060 000000000000000F
RT_Data    0000000007FD0000-0000000007FEFFFF 0000000000000020 800000000000000F
Available  0000000007FF0000-0000000007FFFFFF 0000000000000010 000000000000000F
 
  Reserved  :             27 Pages (110,592 Bytes)
  LoaderCode:            207 Pages (847,872 Bytes)
  LoaderData:              0 Pages (0 Bytes)
  BS_Code   :            642 Pages (2,629,632 Bytes)
  BS_Data   :          4,614 Pages (18,898,944 Bytes)
  RT_Code   :             48 Pages (196,608 Bytes)
  RT_Data   :             85 Pages (348,160 Bytes)
  ACPI_Recl :              8 Pages (32,768 Bytes)
  ACPI_NVS  :            265 Pages (1,085,440 Bytes)
  MMIO      :              0 Pages (0 Bytes)
  MMIO_Port :              0 Pages (0 Bytes)
  PalCode   :              0 Pages (0 Bytes)
  Available :         26,776 Pages (109,674,496 Bytes)
              -------------- 
Total Memory:            127 MB (133,713,920 Bytes)
```

VirtualBoxでの実行結果は、以下のようになった。

```
Type       Start            End              # Pages          Attributes
Available  0000000000000000-000000000009FFFF 00000000000000A0 000000000000000F
Available  0000000000100000-0000000003FFFFFF 0000000000003F00 000000000000000F
BS_Data    0000000004000000-000000000401FFFF 0000000000000020 000000000000000F
Available  0000000004020000-0000000005FF3FFF 0000000000001FD4 000000000000000F
LoaderCode 0000000005FF4000-00000000060B1FFF 00000000000000BE 000000000000000F
RT_Data    00000000060B2000-000000000613BFFF 000000000000008A 800000000000000F
Available  000000000613C000-000000000687BFFF 0000000000000740 000000000000000F
BS_Data    000000000687C000-0000000006899FFF 000000000000001E 000000000000000F
Available  000000000689A000-00000000068B7FFF 000000000000001E 000000000000000F
BS_Data    00000000068B8000-00000000068C4FFF 000000000000000D 000000000000000F
Available  00000000068C5000-00000000068C7FFF 0000000000000003 000000000000000F
BS_Data    00000000068C8000-000000000703BFFF 0000000000000774 000000000000000F
Available  000000000703C000-0000000007052FFF 0000000000000017 000000000000000F
BS_Code    0000000007053000-00000000071BBFFF 0000000000000169 000000000000000F
RT_Code    00000000071BC000-00000000071EBFFF 0000000000000030 800000000000000F
RT_Data    00000000071EC000-000000000720FFFF 0000000000000024 800000000000000F
Reserved   0000000007210000-0000000007213FFF 0000000000000004 000000000000000F
ACPI_Recl  0000000007214000-000000000721BFFF 0000000000000008 000000000000000F
ACPI_NVS   000000000721C000-000000000721FFFF 0000000000000004 000000000000000F
BS_Data    0000000007220000-0000000007240FFF 0000000000000021 000000000000000F
BS_Code    0000000007241000-0000000007256FFF 0000000000000016 000000000000000F
BS_Data    0000000007257000-0000000007459FFF 0000000000000203 000000000000000F
BS_Code    000000000745A000-000000000746AFFF 0000000000000011 000000000000000F
RT_Code    000000000746B000-0000000007F6AFFF 0000000000000B00 800000000000000F
RT_Data    0000000007F6B000-0000000007FEEFFF 0000000000000084 800000000000000F
RT_Code    0000000007FEF000-0000000007FEFFFF 0000000000000001 800000000000000F
MMIO       00000000FFC00000-00000000FFFFFFFF 0000000000000400 8000000000000001
 
  Reserved  :              4 Pages (16,384 Bytes)
  LoaderCode:            190 Pages (778,240 Bytes)
  LoaderData:              0 Pages (0 Bytes)
  BS_Code   :            400 Pages (1,638,400 Bytes)
  BS_Data   :          2,531 Pages (10,366,976 Bytes)
  RT_Code   :          2,865 Pages (11,735,040 Bytes)
  RT_Data   :            306 Pages (1,253,376 Bytes)
  ACPI_Recl :              8 Pages (32,768 Bytes)
  ACPI_NVS  :              4 Pages (16,384 Bytes)
  MMIO      :          1,024 Pages (4,194,304 Bytes)
  MMIO_Port :              0 Pages (0 Bytes)
  PalCode   :              0 Pages (0 Bytes)
  Available :         26,348 Pages (107,921,408 Bytes)
  Persistent:              0 Pages (0 Bytes)
              -------------- 
Total Memory:            127 MB (133,742,592 Bytes)
```

自分のプログラムの調査ではデータがあるとなったところがAvailableになっていることがある。
やはり全部0x00かどうかで使えるページかを判定するのは厳しいかもしれない。
VirtualBoxでは広く連続したAvailableがあるが、
QEMUではACPI_NVSやBS_Dataが挟まっており、
意味は現時点ではよくわからないが潰すとまずい可能性が考えられる。
さらに、QEMUにおいては、0x00が256ページ(16ページ×16行)以上連続している場所においても、
Availableとは限らない(BS_DataやLoaderCodeのことがある)ようである。
そもそもUEFI Shellを起動した時と自分のプログラムを実行した時のメモリマップが
同じだとは限らないので、参考程度かもしれない。

## プログラムからメモリマップが取れるか？

UEFI Shellではなく、自分のプログラムからメモリマップが取れれば、役に立つかもしれない。
QEMUで自分のプログラムを実行し、gdbのfindコマンドで、
UEFI Shellのメモリマップに表示された値のいくつかで検索してみた。

値0x00806000は、アドレス0x7f706a8などに見つかった。
値0x00808000は、アドレス0x7f70670、0x7f709b0、0x7f70ad0、0x7f70b78、0x7f70f68の5個だけに見つかった。
値0x00810000は、アドレス0x7f70160、0x7f70248、0x7f70750、0x7f707f0、0x7f70bb0などに見つかった。

値0x00808000がアドレス0x7f70xxxだけに見つかったので、そのまわりをあさってみる。
アドレス0x7f70000から32ビット整数のダンプをかけると、
一定間隔で下3桁がfffの値が並んでいる様子が見えた。
詳しく見ると、14ワードごとに並んでいるようである。
さらに、アドレス0x7f70000の値は0x70616d6dであり、これは「mmap」という文字列に対応する。
したがって、これがメモリマップである可能性が高そうであり、
1要素のサイズが56バイト(4バイト×14ワード)の配列があると推測できる。
よく見たら、0x70616d6d「mmap」も14ワードごとに並んでいるようである。
アドレス0x7f70000の前を見てみると、0xafafafafが並んでいたので、
やはり今回は0x7f70000がメモリマップデータ(仮)の開始地点のようである。

値0x7f70000をfindで探すと、アドレス0x7f708d8だけに見つかった。
その手前のアドレス0x7f708c0にも値0x70616d6d「mmap」があり、
その周りにも14ワードごとに値0x70616d6d「mmap」が並んでいるようだった。
このあたりの14ワードごとの値0x70616d6d「mmap」の並びは、アドレス0x7f70fc0までのようだ。

メモリから値0x70616d6dを探すプログラム`04_tanken_mmap.c`を作成した。
実行結果を観察した結果、値0x70616d6d「mmap」がきれいに並んでいる部分においては、
値0x70616d6d「mmap」を0ワード目として、
6ワード目のアドレスから8ワード目のアドレスまでの部分が、
4ワード目の値が7であればAvailableと考えられると推測できる。
この判定方法だと、LoaderCodeもAvailableに入ってしまうが、
これはUEFI Shellと自分のプログラムの環境の違いのためであると考えられる。
実際、UEFI Shellを起動した状態で、gdbでテーブル(仮)をチェックすると、
LoaderCodeをAvailableに入れないような感じのテーブル(仮)になっていた。

さらに、この1ワード目と2ワード目の多くは、
このテーブル(仮)の1ワード目のアドレスになっているようであり、
双方向線形リストのようになっていると推測できる。
その中に数個、このまとまったテーブル(仮)とは離れたアドレスが入っている。
この離れたアドレスの場所には2個のアドレスがあり、
それぞれテーブル(仮)中の離れたアドレスがある要素の1ワード目になっている。
たどっていくと一周すると考えるのが自然かもしれない。
これらの離れたアドレスをメモリから探したところ、
アドレスのようなものが多く並んでいる場所の中に複数入っていることがわかったが、
その意味は現時点ではよくわからない。

テーブル(仮)をただの配列としてみると、情報の範囲が重複している。
しかし、ここで線形リストとしてみた場合、離れたアドレスが2通りあることに注目しよう。
そして、離れたアドレスのうち1個が入っている要素に格納されている情報の範囲は、
RAMのはじめと終わりになっているようである。
というわけで、ヒューリスティックで線形リストを認識し、たどるプログラムで確かめてみた。
(`04_tanken_mmap_2.c`)
その結果、予想通り、重複した範囲を持つ線形リストと、
範囲がきれいに昇順に並んだ線形リストの2本にきれいに分かれた。

この範囲がきれいに並んだ線形リストの始点をヒューリスティックに頼らずに
求めることができればさらにいいかもしれないが、
その方法は後で考えるとして、ヒューリスティックで線形リストを探すことにしても
実験用としては十分実用になりそうだと思われる。

## 結論

メモリ内に線形リストでメモリマップの情報がある。
うまくこの線形リストを探し出すことで、
UEFI ShellのmemmapでAvailableとなる場所相当の情報が得られ、
自分のプログラムが情報を保存するのに使えるページの情報として使えると考えられる。

(そういえば、最初「レジスタやメモリの値を出力してみたくなる」として始めたはずなのに、
いつからか「使えるメモリの範囲を得る」にすり替わったなあ)

(自分のプログラムじゃなくてgdbに値を出力させるんかいっ！)
