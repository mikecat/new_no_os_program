# 3. シリアル出力とprintf

## シリアル出力

単に無限ループするだけでは、本当に動いているのかよくわからない。
レジスタやメモリを書き換えても、見える形では出てこない。
やはり目に見える実行結果を出すには、出力デバイスにアクセスするべきである。
ディスプレイに出力したいが、それは比較的難しそうである。
シリアル通信で出力するのが簡単そうだろう。

シリアル通信をするには(また、他のデバイスを扱うためにも)、I/Oポートへのアクセスが必要だ。
[０から作るOS開発　割り込みその２　PICとIRQ](http://softwaretechnique.web.fc2.com/OS_Development/kernel_development03.html)
にはI/Oポートの入出力をするC言語の関数が紹介されているが、
わざわざ関数を呼び出して、1回入出力をして、戻って、というのは効率が悪いという印象が強いので、
今回はマクロとして定義することにした。
ついでに、まだ割り込みを意識しないので使わないが、cliとstiのマクロも置いておいた。
(`lib/io_macro.h`)

これらのマクロを用い、シリアル通信(COM1)の出力をするプログラムを書いた。
(`lib/serial_direct.c` / `lib/serial_direct.h`)
ボーレートを含む各種パラメータは決め打ちである。
また、エラーも考慮しない。
後に作るであろう割り込みを用いたシリアル通信と区別するため、名前に`direct`を入れてある。

ここが参考になった。

* [(serial)PC16550 - os-wiki](http://oswiki.osask.jp/?%28serial%29PC16550)
* [gccのx86インラインアセンブリに関して](http://sci10.org/on_gcc_asm.html)

## printf

`printf()`は便利である。文字列の出力をするなら、やはり`printf()`を使いたい。 (個人の感想です)
というわけで、`printf()`に相当する関数を作ることにした。
(`my_printf.c` / `my_printf.h`)
様々な出力先に対応するため、ベースとなる関数`my_vprintf_base`では、
コールバックを用いて出力するようにした。
1文字ずつの出力では効率が悪い可能性があるため、ある程度まとめて渡せるようにした。
コールバックされる側では、これをそのまま出力するもよし、さらにバッファリングするもよしである。
ただし、目的はあくまで標準`printf()`の再現ではなく文字列の出力なので、
とりあえずは使いそうな機能、そしてそれに伴い低コストで実装できる機能に絞ることにした。
残りの機能を実装したくなったら、また後で実装すればいいだろう。

そして、これを用いて、シリアル通信に出力する`printf_serial_direct`関数を
`libs/serial_direct.c`に作成した。

最後に、これを用いた出力を試してみるコード`03_serial.c`を作成した。
